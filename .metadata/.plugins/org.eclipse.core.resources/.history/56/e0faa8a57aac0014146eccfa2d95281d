package com.iiitb.utility;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.iiitb.blocks.Block;
import com.iiitb.cfg.Accfg;

public class ParseXML {

	public static int countSubSystem = 0;

	// Method returns instance of xml document that can be further parsed
	public static Document initializeDocument(String filePath) {
		Document doc = null;

		try {

			// Parse XML

			File fXmlFile = new File(filePath);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory
					.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();

			doc = dBuilder.parse(fXmlFile);
		} catch (SAXException e) {
			// TODO Auto-generated catch block
			throw new RuntimeException("SAXException in "
					+ ParseXML.class.getName());

		} catch (IOException e) {
			// TODO Auto-generated catch block
			throw new RuntimeException("IOException in "
					+ ParseXML.class.getName());
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			throw new RuntimeException("ParserConfigurationException in "
					+ ParseXML.class.getName());
		}

		return doc;
	}

	// Parse based on Document object. Can be called recursively based on
	// subsystem
	public static Accfg parseDocument(Document doc, Node currSubSystemNode) {

		List<Block> blockList = new ArrayList<Block>();

		try {

			// Parse XML

			NodeList blockChildNodesOfSystemNode = null;
			NodeList lineChildNodesOfSystemNode = null;

			ArrayList<Node> blockChildNodesOfSystemNodeList = new ArrayList<Node>();
			ArrayList<Node> lineChildNodesOfSystemNodeList = new ArrayList<Node>();

			if (currSubSystemNode == null) {
				System.out.println("Testing "
						+ doc.getDocumentElement().getNodeName());

				blockChildNodesOfSystemNode = doc.getElementsByTagName("Block");
				for (int temp = 0; temp < blockChildNodesOfSystemNode
						.getLength(); temp++) {

					blockChildNodesOfSystemNodeList
							.add(blockChildNodesOfSystemNode.item(temp));

				}

				lineChildNodesOfSystemNode = doc.getElementsByTagName("Line");

				
				//For testing
				for (int temp = 0; temp < lineChildNodesOfSystemNode
						.getLength(); temp++) {

					NodeList node = lineChildNodesOfSystemNode.item(temp)
							.getChildNodes();
					for (int iter = 0; iter < node.getLength(); iter++) {
						if (node.item(iter).getNodeName() == "P")

						{

							NamedNodeMap nodeTemp = node.item(iter)
									.getAttributes();

							for (int tempIter = 0; tempIter < nodeTemp
									.getLength(); tempIter++) {
								if (nodeTemp.item(tempIter).getNodeValue()
										.equalsIgnoreCase("SrcBlock")) {
									System.out.println("Source "
											+ node.item(iter).getTextContent());
								}

								if (nodeTemp.item(tempIter).getNodeValue()
										.equalsIgnoreCase("DstBlock")) {
									System.out.println("Destination "
											+ node.item(iter).getTextContent());
								}
							}

							lineChildNodesOfSystemNodeList
									.add(lineChildNodesOfSystemNode.item(temp));

						}

					}
				}
			}

			else {

				System.out.println("Entered else ");

				NodeList tempForProcessing = currSubSystemNode.getChildNodes();
				NodeList tempSubsystemSystemChildren = null;

				System.out.println(currSubSystemNode.getNodeName());
				System.out.println(tempForProcessing.getLength());

				for (int tempForProcessingIter = 0; tempForProcessingIter < tempForProcessing
						.getLength(); tempForProcessingIter++) {

					if (tempForProcessing.item(tempForProcessingIter)
							.getNodeName().equals("System")) {
						tempSubsystemSystemChildren = tempForProcessing.item(
								tempForProcessingIter).getChildNodes();
						System.out.println("Length "
								+ tempSubsystemSystemChildren.getLength());
					}

					else
						continue;
				}

				for (int tempForProcessingIter = 0; tempForProcessingIter < tempSubsystemSystemChildren
						.getLength(); tempForProcessingIter++) {
					System.out.println(tempSubsystemSystemChildren.item(
							tempForProcessingIter).getNodeName());
					if (tempSubsystemSystemChildren.item(tempForProcessingIter)
							.getNodeName().equalsIgnoreCase("Block")) {

						System.out.println(tempSubsystemSystemChildren.item(
								tempForProcessingIter).getNodeName());
						blockChildNodesOfSystemNodeList
								.add(tempSubsystemSystemChildren
										.item(tempForProcessingIter));

					}

					if (tempSubsystemSystemChildren.item(tempForProcessingIter)
							.getNodeName().equalsIgnoreCase("Line")) {

						lineChildNodesOfSystemNodeList
								.add(tempSubsystemSystemChildren
										.item(tempForProcessingIter));

					}

				}

			}

			System.out.println(blockChildNodesOfSystemNodeList);
			System.out.println(lineChildNodesOfSystemNodeList);

			for (int nodeIter = 0; nodeIter < blockChildNodesOfSystemNodeList
					.size(); nodeIter++) {

				NamedNodeMap temp = blockChildNodesOfSystemNodeList.get(
						nodeIter).getAttributes();
				String blockName = "";
				Node blockType = null;
				for (int tempIter = 0; tempIter < temp.getLength(); tempIter++) {
					if (temp.item(tempIter).getNodeName()
							.equalsIgnoreCase("Name")) {
						blockType = blockChildNodesOfSystemNodeList
								.get(nodeIter);

						blockName = temp.item(tempIter).getNodeValue();
					}
				}

				if (blockName != "" && blockType != null) {

					if (blockName.equalsIgnoreCase("Subsystem")) {

						countSubSystem++;
						parseDocument(doc, blockType);

					}

					else {
						NodeList attr = blockType.getChildNodes();

						// Simulink blocks to java library blocks

						Block block = BlockFactory.generateBlock(blockName,
								attr);
						if (block != null)
							blockList.add(block);
					}
				}

			}

			// Setting input to block object's ACCFG based on line tags

			for (int nodeIter = 0; nodeIter < lineChildNodesOfSystemNodeList
					.size(); nodeIter++) {

				// test can be used for any testing purpose

				Block test = FetchInputFromLine.parseLine(
						(ArrayList<Block>) blockList,
						lineChildNodesOfSystemNodeList.get(nodeIter)
								.getChildNodes());

			}

			// BlockList has all blocks with ACCFG set
			// Merge based on topological sort and Display
			return (MergeAccfg.merge((ArrayList<Block>) blockList));

		} catch (Exception e) {
			// TODO Auto-generated catch block
			// throw new RuntimeException("Generic Exception in "
			// + ParseXML.class.getName());
			e.printStackTrace();
		}
		return null;

	}
}
